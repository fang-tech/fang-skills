---
name: java-maven-explorer
description: 自顶向下地引导用户理解 Java/Maven 项目的结构、架构和核心逻辑。通过交互式探索持续构建项目文档。当用户要求理解、分析、探索一个 Java/Maven/Scala 项目，或者想了解项目的架构、模块关系、核心流程时使用。
---

# Java/Maven 项目探索器

一个交互式引导工具，帮助用户自顶向下地理解 Java/Maven 项目。在探索过程中持续构建和完善项目文档。

## 核心理念

1. **自顶向下**：从项目全貌到模块概览，再到核心流程，最后到具体实现
2. **交互式探索**：每一步都向用户提问，引导用户思考并选择探索方向
3. **文档驱动**：所有理解成果持久化到 `.project-understanding/` 目录下的 md 文件中
4. **渐进式深入**：每轮探索后更新文档，逐步完善对项目的理解

---

## 启动流程

当用户要求理解一个 Java/Maven 项目时，执行以下步骤：

### Step 0: 初始化项目理解目录

在项目根目录创建 `.project-understanding/` 目录（如已存在则跳过）：

```
.project-understanding/
├── overview.md              # 项目总览（最先创建）
├── modules.md               # 模块分析
├── architecture.md          # 架构设计
├── core-flows.md            # 核心流程
├── key-classes.md           # 关键类分析
├── dependencies.md          # 依赖关系
├── build-config.md          # 构建配置
├── exploration-log.md       # 探索日志（记录每次探索的问答和发现）
└── glossary.md              # 项目术语表
```

首次运行时创建 `overview.md` 和 `exploration-log.md`，其余文件按需创建。

### Step 1: 全局扫描

自动执行以下分析（不需要用户参与）：

1. **读取根 pom.xml**：提取 groupId、artifactId、版本、打包类型、modules 列表
2. **扫描目录结构**：用 LS/Glob 工具获取项目整体布局
3. **检查 README**：读取项目根目录的 README.md（如有）
4. **识别构建体系**：Maven wrapper / Gradle / 混合构建
5. **识别项目类型**：Spring Boot / Spring Cloud / 普通库 / Spark 插件 / 其他框架

将结果写入 `overview.md`：

```markdown
# 项目总览

## 基本信息
- **项目名称**: {artifactId}
- **GroupId**: {groupId}
- **版本**: {version}
- **打包类型**: {packaging}
- **构建工具**: Maven {version}
- **Java 版本**: {java.version}
- **项目类型**: {type}

## 模块列表
| 模块名 | 路径 | 描述 |
|--------|------|------|
| module-a | modules/module-a | 待分析 |

## 项目简介
{从 README 或 pom description 提取}

## 待探索
- [ ] 模块详细分析
- [ ] 核心架构
- [ ] 关键流程
```

### Step 2: 向用户展示全貌并提问

向用户展示项目总览后，使用 AskQuestion 工具引导：

**第一轮提问**（选择探索方向）：

```
标题：项目探索方向
问题1：你想从哪个角度开始深入了解这个项目？
选项：
- 模块结构（了解各模块的职责和关系）
- 核心流程（追踪一个主要的业务/技术流程）
- 依赖分析（了解项目使用了哪些关键依赖）
- 构建配置（深入理解构建和部署配置）
- 指定模块（直接跳到某个特定模块）

问题2（如果是多模块项目）：你对哪个模块最感兴趣？
选项：{从 pom.xml 提取的模块列表}
```

---

## 探索阶段

根据用户的选择，执行不同的探索路径。每条路径都遵循：**分析 → 展示 → 提问 → 记录** 的循环。

### 路径 A: 模块结构探索

1. **分析每个模块的 pom.xml**：提取依赖、插件、properties
2. **识别模块间依赖**：构建模块依赖图
3. **扫描每个模块的包结构**：`src/main/java/` 下的包组织
4. **归纳模块职责**：根据包名、类名、依赖推断

写入 `modules.md`：

```markdown
# 模块分析

## 模块依赖关系
{描述模块间的依赖关系，可用文字或 ASCII 图}

## 模块详情

### {module-name}
- **路径**: {path}
- **职责**: {推断的职责}
- **关键依赖**: {列出重要依赖}
- **包结构**:
  - `com.example.xxx.api` - API 接口定义
  - `com.example.xxx.impl` - 实现类
  - ...
- **核心类**:
  - `XxxService` - {简要描述}
  - `XxxConfig` - {简要描述}
```

**提问**：
```
你想深入了解哪个模块？或者想看模块间的具体交互方式？
```

### 路径 B: 核心流程追踪

1. **识别入口点**：
   - Spring Boot: `@SpringBootApplication` 类
   - Spark: `main` 方法 或 Extension/Plugin 注册点
   - Library: 公共 API 接口
   - Web: Controller 层
2. **从入口向下追踪**：调用链分析
3. **标注关键节点**：配置加载、核心处理、数据转换等

写入 `core-flows.md`：

```markdown
# 核心流程

## 流程1: {流程名}

### 入口
- 类: `{ClassName}`
- 方法: `{methodName}`
- 触发条件: {描述}

### 调用链
1. `ClassName.method()` - {做了什么}
   2. `AnotherClass.process()` - {做了什么}
      3. `Helper.transform()` - {做了什么}

### 关键逻辑
{描述核心的业务/技术逻辑}

### 配置项
| 配置键 | 默认值 | 说明 |
|--------|--------|------|
| xxx.enabled | true | 是否启用 |
```

**提问**：
```
你想继续追踪这个流程的某个分支，还是探索另一个流程？
```

### 路径 C: 依赖分析

1. **提取所有依赖**：从所有 pom.xml 中收集
2. **分类**：框架依赖 / 工具库 / 测试依赖 / 内部依赖
3. **识别技术栈**：Spring / MyBatis / Spark / Flink 等
4. **标注版本兼容性**：特别关注冲突和 exclusions

写入 `dependencies.md`：

```markdown
# 依赖分析

## 技术栈概览
- **核心框架**: {框架名}
- **数据访问**: {ORM/数据层}
- **构建插件**: {关键插件}

## 依赖分类

### 核心框架
| GroupId | ArtifactId | Version | 用途 |
|---------|-----------|---------|------|

### 工具库
...

### 值得注意的依赖关系
- {描述特殊的依赖管理策略}
```

### 路径 D: 构建配置分析

1. **分析 Maven profiles**
2. **分析 plugins 配置**
3. **分析 properties 和变量管理**
4. **分析 resource filtering**

写入 `build-config.md`。

### 路径 E: 指定模块深入

直接跳到用户指定的模块，进行深度分析：

1. **扫描所有类**：按包分组
2. **识别设计模式**：Factory / Builder / Strategy / Observer 等
3. **分析核心类**：公共方法、继承关系、注解使用
4. **追踪数据流**：输入 → 处理 → 输出

写入 `key-classes.md`。

---

## 持续探索循环

每次探索结束后：

1. **更新文档**：将新发现写入对应的 md 文件
2. **更新探索日志**：在 `exploration-log.md` 追加：

```markdown
## {日期时间} - {探索主题}

### 问题
{用户想了解什么}

### 发现
{本轮探索的关键发现}

### 下一步建议
- {建议1}
- {建议2}
```

3. **提供下一步选择**：

```
基于目前的理解，你可以：
1. 继续深入当前方向的某个细节
2. 切换到另一个探索方向
3. 回顾已有的文档总结
4. 提出一个具体的问题（比如"XXX 是怎么实现的？"）
5. 结束本次探索
```

---

## 术语表维护

在探索过程中遇到项目特有术语时，自动追加到 `glossary.md`：

```markdown
# 项目术语表

| 术语 | 含义 | 首次出现 |
|------|------|----------|
| {term} | {definition} | {在哪个文件/类中} |
```

---

## 文档更新规则

1. **增量更新**：每次只更新有新发现的部分，不重写整个文件
2. **标注确定性**：
   - `[确认]` - 通过代码验证的事实
   - `[推断]` - 基于命名/结构推断，尚未验证
   - `[待验证]` - 需要进一步确认
3. **保持一致性**：使用统一的术语和格式
4. **关联引用**：在文档间使用相对链接互相引用

---

## 特殊场景处理

### Scala 混合项目
如果项目包含 `src/main/scala/`，额外关注：
- Scala 特有的模式匹配、隐式转换、case class
- Spark SQL Extensions、Catalyst 规则
- SBT 和 Maven 混合构建

### 多仓库/子模块项目
- 检查 `.gitmodules`
- 识别仓库边界
- 记录跨仓库依赖

### Spring Boot 项目
- 自动扫描 `application.yml` / `application.properties`
- 识别 auto-configuration
- 追踪 Bean 注册和依赖注入

---

## 快速命令

用户可以在任何时候说：

| 命令 | 含义 |
|------|------|
| "总结一下" | 展示当前所有文档的概要 |
| "更新文档" | 强制将当前理解写入文档 |
| "探索 {模块名}" | 直接跳到指定模块 |
| "追踪 {类名/方法名}" | 从指定位置开始流程追踪 |
| "这个类是干什么的" | 分析当前打开/提到的类 |
| "画个架构图" | 生成 ASCII 架构图并写入文档 |

---

## 探索质量原则

1. **先广后深**：先建立全局认知，再深入细节
2. **用户引导**：不要自说自话，每一步都让用户参与选择
3. **代码为据**：所有结论必须有代码引用支撑
4. **实时记录**：不要等到最后才写文档，边探索边记录
5. **关联思维**：发现新内容时主动关联已有知识，更新相关文档
