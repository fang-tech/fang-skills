---
name: java-maven-explorer
description: 自顶向下地引导用户理解 Java/Maven 项目的结构、架构和核心逻辑。根据用户水平自适应解释深度，通过交互式探索持续构建项目文档。当用户要求理解、分析、探索一个 Java/Maven/Scala 项目，或者想了解项目的架构、模块关系、核心流程时使用。
---

# Java/Maven 项目探索器

一个交互式引导工具，帮助用户自顶向下地理解 Java/Maven 项目。根据用户的知识水平自适应调整解释粒度，在探索过程中持续构建和完善项目文档。

## 核心理念

1. **用户适配**：先了解用户的知识背景，按水平调整解释深度和方式
2. **自顶向下**：从项目全貌到模块概览，再到核心流程，最后到具体实现
3. **不假设用户知道**：遇到框架概念、设计模式、领域术语时主动解释，不跳过
4. **交互式探索**：每一步都向用户提问，引导用户思考并选择探索方向
5. **文档驱动**：所有理解成果持久化到 `.project-understanding/` 目录下的 md 文件中
6. **渐进式深入**：每轮探索后更新文档，逐步完善对项目的理解

---

## 启动流程

当用户要求理解一个 Java/Maven 项目时，**必须按顺序**执行以下步骤：

### Step 0: 用户画像评估（最重要的第一步）

在做任何项目分析之前，先了解用户。使用 AskQuestion 工具：

```
标题：开始之前，先了解一下你
问题1：你对 Java/Maven 生态的熟悉程度？
选项：
- 入门（知道 Java 基础语法，Maven 只大概知道是构建工具）
- 熟悉（写过 Java 项目，用过 Maven 管理依赖，了解 Spring 等框架）
- 精通（深入理解 Maven 生命周期、插件机制，熟悉多种框架的内部原理）

问题2：你和这个项目的关系？
选项：
- 完全陌生（第一次接触，不知道这个项目是做什么的）
- 大致了解（知道项目的用途，但没看过代码）
- 部分了解（看过一些代码或文档，但不系统）
- 参与开发（在项目中工作，但想理解不熟悉的部分）

问题3：你想理解这个项目的目的是？
选项：
- 学习研究（纯粹想学习这个项目的设计思路）
- 接手维护（需要接手这个项目，需要快速上手）
- 排查问题（遇到了 bug 或性能问题，需要理解相关模块）
- 二次开发（需要在此基础上开发新功能或做改造）
```

根据回答建立用户画像，写入 `.project-understanding/user-profile.md`：

```markdown
# 用户画像

- **技术水平**: {入门/熟悉/精通}
- **项目熟悉度**: {完全陌生/大致了解/部分了解/参与开发}
- **探索目的**: {学习研究/接手维护/排查问题/二次开发}
- **建立时间**: {日期}

## 解释策略
{根据画像自动生成的策略，见下方规则}
```

#### 解释策略规则

根据用户画像，在后续所有探索中遵循对应的策略：

**入门用户**：
- 遇到 Maven 概念（lifecycle、phase、goal、plugin）时必须解释是什么、为什么需要
- 遇到设计模式时用简单类比解释（如："工厂模式就像一个车间，你告诉它要什么产品，它帮你生产"）
- 遇到框架注解（`@Autowired`、`@Bean`、`@SparkExtension` 等）时解释注解的含义和作用机制
- 代码阅读时先说"这段代码在做什么"，再说"怎么做的"
- 主动补充前置知识："在看这个之前，你需要知道 XXX 的概念..."
- 术语表（glossary.md）中对每个术语都给出通俗解释

**熟悉用户**：
- Maven 基础概念可以一带而过，但 profile、shade plugin 等进阶特性需要解释
- 设计模式点到即可（"这里用了策略模式"），不需要展开类比
- 框架的常见用法（如 Spring DI）不需解释，但项目特有的框架用法需要说明
- 重点放在 "项目为什么这么设计" 而非 "这个技术是什么"
- 术语表只收录项目专有术语，通用技术术语可省略

**精通用户**：
- 跳过所有通用技术解释，直奔项目特有的设计决策和实现细节
- 重点放在：架构取舍、性能考量、与其他方案的对比
- 可以使用专业术语，不需要额外解释
- 鼓励用户提出对设计的质疑和改进建议
- 术语表只记录项目内部的领域缩写和约定

**按探索目的调整侧重点**：
- 接手维护：侧重"怎么改"、"改哪里"、"改了会影响什么"
- 排查问题：侧重数据流、异常处理链、日志埋点位置
- 二次开发：侧重扩展点、接口设计、插件机制
- 学习研究：侧重设计思路、架构演进、技术选型理由

### Step 1: 初始化项目理解目录

在项目根目录创建 `.project-understanding/` 目录（如已存在则跳过）：

```
.project-understanding/
├── user-profile.md          # 用户画像（最先创建）
├── overview.md              # 项目总览
├── modules.md               # 模块分析
├── architecture.md          # 架构设计
├── core-flows.md            # 核心流程
├── key-classes.md           # 关键类分析
├── dependencies.md          # 依赖关系
├── build-config.md          # 构建配置
├── exploration-log.md       # 探索日志（记录每次探索的问答和发现）
└── glossary.md              # 项目术语表
```

首次运行时创建 `user-profile.md`、`overview.md` 和 `exploration-log.md`，其余文件按需创建。

### Step 2: 全局扫描

自动执行以下分析（不需要用户参与）：

1. **读取根 pom.xml**：提取 groupId、artifactId、版本、打包类型、modules 列表
2. **扫描目录结构**：用 LS/Glob 工具获取项目整体布局
3. **检查 README**：读取项目根目录的 README.md（如有）
4. **识别构建体系**：Maven wrapper / Gradle / 混合构建
5. **识别项目类型**：Spring Boot / Spring Cloud / 普通库 / Spark 插件 / 其他框架

将结果写入 `overview.md`（模板见 templates/overview-template.md）。

**重要**：向用户展示全局扫描结果时，根据用户水平调整表述：
- 入门用户：先用一句大白话概括"这个项目是做什么的"，再展开细节
- 熟悉用户：概要 + 关键信息即可
- 精通用户：直接给结构化数据，减少废话

### Step 3: 向用户展示全貌并提问

向用户展示项目总览后，使用 AskQuestion 工具引导。

**关键：提问时也要适配用户水平**：
- 入门用户的选项要有解释性描述
- 精通用户的选项可以更直接

**入门用户版本**：
```
标题：项目探索方向
问题1：接下来你想先了解什么？
选项：
- 项目的组成部分（这个项目有哪些子项目/模块，各自做什么）
- 看一个完整的流程（跟着一个请求从头到尾走一遍，看它经过了哪些代码）
- 项目用了哪些技术（依赖了什么框架和库，为什么选它们）
- 项目怎么编译打包的（Maven 构建配置是怎么设置的）
- 我对某个具体的部分感兴趣（直接跳到某个模块或文件）
```

**熟悉/精通用户版本**：
```
标题：项目探索方向
问题1：你想从哪个角度开始深入？
选项：
- 模块结构与依赖关系
- 核心流程追踪
- 依赖分析与技术栈
- 构建配置（profiles / plugins / properties）
- 指定模块深入分析

问题2（如果是多模块项目）：对哪个模块最感兴趣？
选项：{从 pom.xml 提取的模块列表}
```

---

## 上下文感知解释机制

在整个探索过程中，**永远不要假设用户知道某个上下文**。遵循以下原则：

### 遇到以下情况时必须主动解释

1. **项目内部约定**：自定义注解、命名约定、内部 DSL、配置键名
   - 错误示范：`"AscendConf 中定义了配置"`
   - 正确示范：`"AscendConf 是这个项目的统一配置管理类，所有 Spark 相关的配置项都在这里注册。每个配置通过 buildConf() 方法定义，包含键名、默认值和文档说明。"`

2. **隐式依赖和魔法行为**：SPI、反射加载、auto-configuration、隐式转换
   - 这些代码中"看不到的连接"是用户最容易困惑的地方
   - 必须明确指出："这个类不是直接被调用的，而是通过 XXX 机制自动加载的"

3. **框架约定优于配置**（Convention over Configuration）：
   - Spring Boot 的自动装配、Maven 的目录约定、Spark 的 Extension 注册
   - 入门用户需要解释约定本身；熟悉用户需要指出项目对约定的定制

4. **项目独有的架构模式**：
   - 不是通用的 MVC/微服务，而是项目团队自己设计的分层方式
   - 必须说明 "为什么这个项目要这样分层" 而不只是 "它分了这些层"

5. **跨模块/跨文件的隐含关系**：
   - 模块 A 的某个接口在模块 B 中被实现，在模块 C 中被调用
   - 用户看单个文件时不可能知道全貌，必须主动补全

### 解释的层次结构（每次解释都遵循）

```
第1层：这是什么（一句话）
第2层：它在项目中扮演什么角色（上下文）
第3层：它是怎么工作的（机制）
第4层：为什么这样设计（决策理由，如果能推断）
```

- 入门用户：展开到第3-4层
- 熟悉用户：展开到第2层，按需到第3层
- 精通用户：通常只需第1层，对有趣的设计展开第4层

### "你可能会好奇"机制

在解释过程中，主动预判用户可能的疑惑，用以下模式插入补充说明：

```
> 💡 你可能会好奇：为什么这里用了 XXX 而不是更常见的 YYY？
> 这是因为 ...
```

这种方式特别适合：
- 看起来反直觉的设计选择
- 项目中出现的不常见的技术组合
- 代码中的 workaround 或 hack

---

## 探索阶段

根据用户的选择，执行不同的探索路径。每条路径都遵循：**分析 → 用户水平适配的解释 → 提问 → 记录** 的循环。

### 路径 A: 模块结构探索

1. **分析每个模块的 pom.xml**：提取依赖、插件、properties
2. **识别模块间依赖**：构建模块依赖图
3. **扫描每个模块的包结构**：`src/main/java/` 下的包组织
4. **归纳模块职责**：根据包名、类名、依赖推断

写入 `modules.md`（模板见文件末尾模块分析模板）。

**展示时的水平适配**：
- 入门用户：用类比解释模块关系，如 "module-core 相当于地基，其他模块都建在它上面"
- 熟悉用户：用依赖图 + 职责总结
- 精通用户：直接给依赖矩阵和设计决策分析

**提问时检查理解**：
```
入门版：到目前为止，你觉得哪个模块的作用还不太清楚？或者你想看看它们之间具体是怎么配合工作的？
标准版：你想深入了解哪个模块？或者想看模块间的具体交互方式？
```

### 路径 B: 核心流程追踪

1. **识别入口点**：
   - Spring Boot: `@SpringBootApplication` 类
   - Spark: `main` 方法 或 Extension/Plugin 注册点
   - Library: 公共 API 接口
   - Web: Controller 层
2. **从入口向下追踪**：调用链分析
3. **标注关键节点**：配置加载、核心处理、数据转换等
4. **在每个关键节点暂停**：检查用户是否理解到这一步

写入 `core-flows.md`。

**关键：流程追踪时的"暂停检查点"**：

在追踪较长的调用链时（超过3步），要在关键节点暂停并确认：
```
我们现在追踪到了 XxxProcessor.process() 方法。
到这里为止：
- 请求先经过了 Controller 层的参数校验
- 然后通过 Service 层转发到了 Processor
- Processor 是这个流程的核心处理逻辑所在

在继续往下看之前，到这里有什么不清楚的吗？还是继续深入 Processor 的实现？
```

这避免了用户在一长串调用链中"迷路"。

### 路径 C: 依赖分析

1. **提取所有依赖**：从所有 pom.xml 中收集
2. **分类**：框架依赖 / 工具库 / 测试依赖 / 内部依赖
3. **识别技术栈**：Spring / MyBatis / Spark / Flink 等
4. **标注版本兼容性**：特别关注冲突和 exclusions

写入 `dependencies.md`。

**水平适配**：
- 入门用户：对每个关键依赖用一句话解释"它是干什么的，为什么需要它"
- 熟悉用户：标注哪些是常见选型，哪些是不寻常的选择
- 精通用户：聚焦版本兼容性策略、shade/relocate 等高级技巧

### 路径 D: 构建配置分析

1. **分析 Maven profiles**
2. **分析 plugins 配置**
3. **分析 properties 和变量管理**
4. **分析 resource filtering**

写入 `build-config.md`。

### 路径 E: 指定模块深入

直接跳到用户指定的模块，进行深度分析：

1. **扫描所有类**：按包分组
2. **识别设计模式**：Factory / Builder / Strategy / Observer 等
3. **分析核心类**：公共方法、继承关系、注解使用
4. **追踪数据流**：输入 → 处理 → 输出

写入 `key-classes.md`。

**重要：深入模块时的"上下文补全"**：

当用户直接跳到某个模块时，自动检查并补全前置知识：
```
在深入 spark-plugin 模块之前，有几个背景信息需要了解：
1. 这个模块是作为 Spark 的 Extension 加载的（如果你不熟悉 Spark Extension 机制，我可以先解释）
2. 它依赖 core 模块中的 XXX 接口
3. 它的配置项都注册在 AscendConf 中

需要我先展开哪个背景知识，还是直接开始看代码？
```

---

## 持续探索循环

每次探索结束后：

1. **更新文档**：将新发现写入对应的 md 文件
2. **更新探索日志**：在 `exploration-log.md` 追加：

```markdown
## {日期时间} - {探索主题}

### 背景
{为什么要探索这个方向}

### 问题
{用户想了解什么}

### 用户当时不清楚的点
{在探索中发现的用户知识盲区，用于后续优化解释策略}

### 发现
{本轮探索的关键发现}

### 为用户补充的知识
{本轮额外解释了哪些前置知识}

### 下一步建议
- {建议1}
- {建议2}
```

3. **动态调整用户画像**：如果在探索中发现用户的水平与初始评估不符（比如声称入门但提出了高级问题，或声称精通但对某些概念不熟悉），更新 `user-profile.md` 中的策略

4. **提供下一步选择**（用自然语言，不要只列选项）：

```
我们现在已经了解了 {总结已探索内容}。

基于目前的理解，有几个方向可以继续：
- {方向1}：因为刚才我们看到 {关联信息}，继续深入可以了解...
- {方向2}：你之前提到想 {用户之前的兴趣}，现在可以...
- 或者你有任何具体的疑问想追问？

当然，也可以回顾已有的文档，或者结束本次探索。
```

---

## 术语表维护

在探索过程中遇到项目特有术语时，自动追加到 `glossary.md`：

```markdown
# 项目术语表

| 术语 | 含义 | 通俗解释 | 首次出现 |
|------|------|----------|----------|
| {term} | {精确定义} | {大白话解释，针对入门用户} | {在哪个文件/类中} |
```

"通俗解释"列对入门用户展示，对精通用户隐藏。

---

## 文档更新规则

1. **增量更新**：每次只更新有新发现的部分，不重写整个文件
2. **标注确定性**：
   - `[确认]` - 通过代码验证的事实
   - `[推断]` - 基于命名/结构推断，尚未验证
   - `[待验证]` - 需要进一步确认
3. **保持一致性**：使用统一的术语和格式
4. **关联引用**：在文档间使用相对链接互相引用
5. **标注知识前提**：在文档段落旁标注理解该段落需要的前置知识
   - `<!-- 前置知识: Maven 生命周期, Spark Extension 机制 -->`

---

## 特殊场景处理

### Scala 混合项目
如果项目包含 `src/main/scala/`，额外关注：
- Scala 特有的模式匹配、隐式转换、case class
- Spark SQL Extensions、Catalyst 规则
- SBT 和 Maven 混合构建
- **注意**：入门用户可能不了解 Scala，需要解释与 Java 的关键差异

### 多仓库/子模块项目
- 检查 `.gitmodules`
- 识别仓库边界
- 记录跨仓库依赖

### Spring Boot 项目
- 自动扫描 `application.yml` / `application.properties`
- 识别 auto-configuration
- 追踪 Bean 注册和依赖注入
- **注意**：入门用户需要解释 IoC/DI 的基本概念

---

## 快速命令

用户可以在任何时候说：

| 命令 | 含义 |
|------|------|
| "总结一下" | 展示当前所有文档的概要 |
| "更新文档" | 强制将当前理解写入文档 |
| "探索 {模块名}" | 直接跳到指定模块（会自动补全上下文） |
| "追踪 {类名/方法名}" | 从指定位置开始流程追踪 |
| "这个类是干什么的" | 分析当前打开/提到的类 |
| "画个架构图" | 生成 ASCII 架构图并写入文档 |
| "这个我不懂" | 对最近讨论的内容做更详细的解释 |
| "跳过解释" | 临时切换到精通模式，减少解释 |
| "详细一点" | 临时切换到入门模式，增加解释 |

---

## 探索质量原则

1. **不假设，常确认**：永远不假设用户知道某个上下文，宁可多问一句
2. **先广后深**：先建立全局认知，再深入细节
3. **用户引导**：不要自说自话，每一步都让用户参与选择
4. **代码为据**：所有结论必须有代码引用支撑
5. **实时记录**：不要等到最后才写文档，边探索边记录
6. **关联思维**：发现新内容时主动关联已有知识，更新相关文档
7. **回头看路**：长时间探索后定期回顾，帮用户串联已学到的知识
8. **承认不确定**：对于推断性的结论要明确标注，不要让用户误以为是确认的事实
